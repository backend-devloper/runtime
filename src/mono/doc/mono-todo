* Mono hacking TODO list

	From time to time people that want to contribute to Mono ask
	on the mailing list what they can help with. The generic
	answer is always:
	<ul>
	* Write documentation.
	* Write regression tests.
	* Complete the implementations of the class libraries.
	* Help fix the bugs filed in our bugzilla database.
	</ul>

	The proposed tasks are very important for the Mono project and
	are suitable for people that can dedicate even just an hour
	per week to contribute.  But some people may need something
	more focused to work on, such as students that want to do a
	thesis on their contribution to Mono. For such people (and
	also for professors who want ideas for thesis regarding JIT or
	VM technologies), here is a list of tasks that need attention.

	The estimated time to complete any of the tasks is between 1
	week to several months to accomodate for different hacking
	possibilities.

	Note on the time estimates: they are very rough estimates, a
	smart and dedicated hacker can complete the tasks in half of
	the minimum time, a part-time hacker that also has a social
	life can take more than double the max time, but there's
	nothing to worry as long as progress is being done.

	If some people (or group of people) want to take on a task,
	they should write to the mono-devel mailing list and in the
	relative bugzilla bug report. Discussions about how to
	implement a feature or additional information on the task
	should be mailed to the list or in the bugzilla report as well
	so that people can keep informed on the progress or have the
	information needed to start contributing.
	
	Mono is an excellent platform for research on JITs, virtual
	machines and specifically the CLR because it provides an
	advanced free software implementation that can be used as a
	basis for more optimizations, new approaches to problems and
	new features.

	There are different areas of interest where high-level
	contributions can be made:

	<ul>
	* <b>JIT compiler</b>: tasks can be: adding more optimizations, reducing 
	compile time, porting to different architectures.

	* <b>AOT compiler</b>: optimizing the compiler output and the AOT loader,
	better support for multiple application domains.
	
	* <b>VM runtime</b>: optimizing the runtime data structures, experimenting with
	different garbage collectors, integration with different component models.
	
	* <b>Class library</b>: many opportunities in the implementation of regular 
	expressions, Xml related technologies (XPath, XLST, etc).

	* <b>Compilers</b>: writing compilers, interpreters and runtimes for langauges
	so that they run on the CLR (using Reflection.Emit support, for example).
	</ul>

Happy hacking!

<table border=1 cellspacing="0" cellpadding="0">
	<tr>
		<th>Area<th>Description<th>Difficulty<th>Time estimate<th>Bugzilla ID
	</tr>

	<tr>
		<td>Runtime (mono/metadata)
		<td>Optimize method vtable. Currently all the methods in a class
		are added to the method vtable, including static and non-virtual methods.
		This makes vtables bigger and the instructions to access them are longer, 
		increasing also code size. Some code in metadata/icall.c and maybe also some 
		remoting code may depend on the current layout: such code should be fixed as well.
		<td>Medium
		<td>1-2 weeks
		<td>not assigned
	</tr>

	<tr>
		<td>System assembly (mcs/class/System/)
		<td>Implement the IL-based regular expression engine. Instead of
		intepreting the regular expression pattern, a method is created at runtime using
		Reflection.Emit. This makes for faster pattern matching because there is no 
		intepreter overhead and the matching code is jitted to fast native code.
		Bonus points if the compiled regular expression is compatible with the ones generated 
		by the MS runtime.
		<td>Medium-hard (thesis subject)
		<td>2-4 months
		<td>not assigned
	</tr>

	<tr>
		<td>JIT (mono/mini/)
		<td>Implement common subexpression elimination.
		Global and local common subexpression elimination needs to be implemented
		to achieve better performance. The local case is easier and may take just one month.
		It should be implemented in the context of the SSA framework (mini/ssa.c).
		<td>Hard (thesis subject)
		<td>2-4 months 
		<td>not assigned
	</tr>

	<tr>
		<td>JIT (mono/mini/)
		<td>Optimize AOT compiler output.
		Currently the code generated by the AOT compiler may be significantly slower than
		jitted code. This is mostly because the AOT code supports multiple application domains
		and some values that are constant at JIT-time are not constant at AOT-time. It may be
		needed to write a simple dynamic linker and/or binary object writer. Bonus poinst if
		it supports ELF, PE/COFF and mach-O binary formats. A possible idea for improvements 
		is also the use of appdomain ID-indexed tables to get at the appdomain specific data.
		<td>Medium-hard (thesis subject)
		<td>3-6 months
		<td>not assigned
	</tr>

	<tr>
		<td>JIT (mono/mini/)
		<td>Implement generics support.
		We need to add support for the additional instructions and change existing ones to
		support the generics requirements.
		<td>Medium-hard
		<td>2-3 months
		<td>not assigned
	</tr>

	<tr>
		<td>JIT (mono/mini/)
		<td>Port the JIT to additional architectures.
		Currently ports are in the works for ppc, arm, sparc, s390. None of the ports
		are as feature-complete as the x86 one, yet, so help is needed in getting them
		up to speed. Ports to more architectures are welcome as well.
		<td>Medium-hard
		<td>3-6 months per arch
		<td>not assigned
	</tr>

	<tr>
		<td>Runtime and JIT (mono/metadata and mono/mini/)
		<td>Add support for COM and/or XPCOM and/or ORBit.
		We need a way to seamlessy use existing component technologies inside the mono runtime.
		The COM support needs to match the MS runtime behaviour and is targeted at windows systems.
		XPCOM and ORBit support are important on Unix platforms. Bonus points for developing
		the runtime support so that different component systems can be used at the same time.
		<td>Medium-hard (thesis subject)
		<td>3-4 months for each
		<td>not assigned
	</tr>

	<tr>
		<td>Runtime and JIT (mono/metadata and mono/mini/)
		<td>Implement support for Code Access Security.
		Support needs to be added to the JIT and the runtime to ensure
		code that executes privileged operations is permitted to do so.
		The task includes loading the security information from metadata,
		collecting evidence, inserting calls to the permission objects, 
		stack walking to collect security info.
		<td>Medium-hard (thesis subject)
		<td>4-5 months
		<td>not assigned
	</tr>

	<tr>
		<td>Runtime and JIT (mono/metadata and mono/mini/)
		<td>Implement support for a generational GC.
		We're currently using a conservative non-moving GC.
		Support for a generational and moving GC requires changes to the JIT
		(to record locations in frames as well as registers that may contain 
		pointers to GC-allocated memory) and to the runtime code (when
		objects are manipulated directly we should make sure they are pinned
		and reachable by the GC also in the C unmanaged code). Code from an existing
		precise GC such as the ORP one could be reused or a new GC may be developed
		(increasing the estimated development time).
		<td>Hard (thesis subject)
		<td>6-8 months
		<td>not assigned
	</tr>

	<tr>
		<td>Compilers for dynamic languages
		<td>Write a IL compiler and runtime support for dynamic languages like
		Python, Perl, Ruby, PHP.
		<td>Medium-hard (thesis subject)
		<td>6-12 months
		<td>not assigned
	</tr>

</table>

