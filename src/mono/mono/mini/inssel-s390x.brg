%%

#
# inssel-s390x.brg: burg file for special s390 instructions
#
# Author:
#   Neale Ferguson (Neale.Ferguson@SoftwareAG-usa.com)
#   Dietmar Maurer (dietmar@ximian.com)
#   Paolo Molaro (lupus@ximian.com)
#
# (C) 2002 Ximian, Inc.
#

stmt: OP_START_HANDLER {
	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
	tree->inst_left = spvar;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFINALLY {
	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
	tree->inst_left = spvar;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_ENDFILTER (reg) {
	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
	tree->inst_left = spvar;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LADD_OVF (reg, reg),
reg: OP_LADD_OVF_UN (reg, reg),
reg: OP_LSUB_OVF (reg, reg),
reg: OP_LSUB_OVF_UN (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_ADD_OVF (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, OP_IADD_OVF, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_ADD_OVF_UN (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, OP_IADD_OVF_UN, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_SUB_OVF (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, OP_ISUB_OVF, state->reg1, state->left->reg1, state->right->reg1);
}

reg: CEE_SUB_OVF_UN (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, OP_ISUB_OVF_UN, state->reg1, state->left->reg1, state->right->reg1);
}

stmt: CEE_STIND_I8 (OP_REGVAR, reg) {
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, state->left->tree->dreg, state->right->reg1);
}

reg: CEE_LDIND_I8 (OP_REGVAR) {
	state->reg1 = state->left->tree->dreg;
}

freg: OP_LCONV_TO_R8 (lreg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	tree->sreg2 = state->left->reg2;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_LCONV_TO_R4 (lreg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	tree->sreg2 = state->left->reg2;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: CEE_CONV_R_UN (reg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: CEE_CONV_R_UN (reg) {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_MEMCPY (reg, reg) "0" {
	int size = tree->backend.memcpy_args->size;
	if (size > 0) 
		MONO_EMIT_NEW_MOVE (s, state->left->reg1, 0, state->right->reg1, 0, size);
}

stmt: OP_MEMCPY (base, base) "0" {
	int size = tree->backend.memcpy_args->size;
	if (size > 0)  
		MONO_EMIT_NEW_MOVE (s, state->left->tree->sreg1, 
				    state->left->tree->inst_offset, 
				    state->right->tree->sreg1,
				    state->right->tree->inst_offset,
				    size);
}

reg: OP_LOCALLOC (OP_ICONST) {
	/* microcoded in mini-s390.c */
	tree->sreg1 = mono_regstate_next_int (s->rs);
	tree->dreg  = state->reg1;
	MONO_EMIT_NEW_ICONST (s, tree->sreg1, state->left->tree->inst_c0);
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LOCALLOC (reg) {
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->reg1;
        mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = s390_r2;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (freg) {
	if (mono_method_signature (s->method)->ret->type == MONO_TYPE_R4) {
		tree->opcode = OP_S390_SETF4RET;
		tree->sreg1  = state->left->reg1;
	} else {
		tree->opcode = OP_FMOVE;
	    tree->dreg = s390_f0;
		tree->sreg1  = state->left->reg1;
	}
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (OP_ICONST) {
	tree->opcode = OP_ICONST;
	tree->inst_c0 = state->left->tree->inst_c0;
	tree->dreg = s390_r2;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (reg) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode = OP_MOVE;
	tree->dreg   = mono_regstate_next_int (s->rs);
	tree->sreg1  = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG_MEMBASE (reg) {
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, STK_BASE, 
				     arg->offset, state->left->reg1);
}

stmt: OP_OUTARG (OP_REGVAR) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode       = OP_MOVE;
	tree->dreg         = mono_regstate_next_int (s->rs);
	tree->sreg1        = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG_MEMBASE (OP_REGVAR) {
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, STK_BASE, 
				     arg->offset, state->left->tree->dreg);
}

stmt: OP_OUTARG (OP_I8CONST),
stmt: OP_OUTARG (OP_ICONST) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode       = OP_ICONST;
	tree->dreg 	   = mono_regstate_next_int (s->rs);
	tree->inst_c0 	   = state->left->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG_MEMBASE (OP_ICONST) {
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STORE_MEMBASE_IMM, STK_BASE, 
				         arg->offset, state->left->tree->inst_c0);
}

stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode       = OP_MOVE;
	tree->sreg1        = state->left->left->tree->dreg;
	tree->dreg         = mono_regstate_next_int (s->rs);
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
}

stmt: OP_OUTARG_MEMBASE (CEE_LDIND_REF (OP_REGVAR)) {
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STORE_MEMBASE_IMM, STK_BASE, 
				         arg->offset, state->left->tree->inst_c0);
}

stmt: OP_OUTARG_MEMBASE (OP_LDADDR (OP_S390_LOADARG)) {
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, STK_BASE, 
				     arg->offset, state->left->left->tree->dreg);
}

freg: OP_FCONV_TO_R4 (freg) "0" { 
	MONO_EMIT_UNALU (s, tree, OP_FMOVE, state->reg1, state->left->reg1);
}

stmt: OP_OUTARG_R4 (freg) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode = OP_S390_SETF4RET;
	tree->dreg   = mono_regstate_next_float (s->rs);
	tree->sreg1  = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, TRUE);
}

stmt: OP_OUTARG_R8 (freg),
stmt: OP_OUTARG (freg) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode = OP_FMOVE;
	tree->dreg   = mono_regstate_next_float (s->rs);
	tree->sreg1  = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, TRUE);
}

stmt: OP_OUTARG_MEMBASE (freg) {
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	/*----------------------------------------------*/
	/* The length stored in size tells us whether   */
	/* we need to store a float or a double		*/
	/*----------------------------------------------*/
	if (arg->size == 4) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER4_MEMBASE_REG, 
					     STK_BASE, arg->offset+4,
					     state->left->reg1);
	} else {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, 
					     STK_BASE, arg->offset,
					     state->left->reg1);
	}
}

stmt: OP_OUTARG_R4 (CEE_LDOBJ (OP_REGOFFSET)),
stmt: OP_OUTARG_R8 (CEE_LDOBJ (OP_REGOFFSET)) {
	MonoCallInst *call = (MonoCallInst*) tree->inst_right;

	tree->opcode = OP_FMOVE;
	tree->dreg   = mono_regstate_next_float (s->rs);
	tree->sreg1  = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);

	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, TRUE);
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (base)) {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;
	MonoInst *vt         = state->left->left->tree;
	
	int start_reg = tree->sreg1;
	int size      = arg->size;
	int soffset   = vt->inst_offset;
	int treg;
	
	if (size < 0) { 
		size = -size;
		treg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_MOVE(s, STK_BASE, arg->offPrm, 
				   vt->inst_basereg, soffset, size);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, STK_BASE, arg->offPrm);
		if (start_reg != STK_BASE) {
			mono_call_inst_add_outarg_reg (s, call, treg, start_reg, FALSE);
		} else { 
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, 
						     STK_BASE, arg->offset, treg);
		}
	} else {
		if (start_reg != STK_BASE) {
			MONO_OUTPUT_VTR (s, size, start_reg, vt->inst_basereg, soffset);
		} else {
			MONO_OUTPUT_VTS (s, size, STK_BASE, arg->offset,
					 vt->inst_basereg, soffset);
		}	
	}
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (OP_S390_ARGPTR)) {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;
	MonoInst *vt         = state->left->left->tree;
	
	int start_reg = tree->sreg1;
	int size      = arg->size;
	int soffset   = vt->inst_offset;

//printf("OP_OUTARG_VT(CEE_LDOBJ(OP_S390_ARGPTR))\n");
	if (start_reg != STK_BASE) {
		MONO_OUTPUT_VTR (s, size, start_reg, vt->inst_basereg, soffset);
	} else {
		MONO_OUTPUT_VTS (s, size, STK_BASE, arg->offset,
				 vt->inst_basereg, soffset);
	}	
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (OP_REGOFFSET)) "0" {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;
	MonoInst *vt         = state->left->left->tree;
	
	int start_reg = tree->sreg1;
	int size      = arg->size;
	int soffset   = vt->inst_offset;
	int treg;

//printf("OP_OUTARG_VT(CEE_LDOBJ(OP_REGOFFSET))\n");
	if (size < 0) { 
		size = -size;
		treg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_MOVE (s, STK_BASE, arg->offPrm,
				    vt->inst_basereg, soffset, size);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, STK_BASE, arg->offPrm);
		if (start_reg != STK_BASE) {
			mono_call_inst_add_outarg_reg (s, call, treg, start_reg, FALSE);
		} else {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, 
						     STK_BASE, arg->offset, treg);
		}
	} else {
		if (start_reg != STK_BASE) {
			MONO_OUTPUT_VTR(s, size, start_reg, vt->inst_basereg, soffset);
		} else {
			MONO_OUTPUT_VTS(s, size, STK_BASE, arg->offset,
				 	  vt->inst_basereg, soffset);
		}	
	}
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (OP_S390_LOADARG)) {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;
	MonoInst *vt         = state->left->left->tree;
	
	int start_reg = tree->inst_basereg;
	int size      = -arg->size;
	int soffset   = vt->inst_offset;
	int treg;

//printf("OP_OUTARG_VT(CEE_LDOBJ(OP_S390_LOADARG))\n");
	treg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, treg, s->frame_reg);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, treg, treg, vt->backend.arg_info);
	MONO_EMIT_NEW_MOVE (s, STK_BASE, soffset, treg, 0, size);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, STK_BASE, soffset);
	if (start_reg != STK_BASE) {
		mono_call_inst_add_outarg_reg (s, call, treg, start_reg, FALSE);
	} else {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, 
					     STK_BASE, arg->offset, treg);
	}
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (OP_S390_ARGREG)) {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;
	MonoInst *vt         = state->left->left->tree;
	
	int start_reg = tree->inst_basereg;
	int size      = -arg->size;
	int soffset   = vt->inst_offset;
	int treg;

//printf("OP_OUTARG_VT(CEE_LDOBJ(OP_S390_ARGREG))\n");
	treg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, treg, s->frame_reg, soffset);
	MONO_EMIT_NEW_MOVE (s, STK_BASE, arg->offPrm, treg, 0, size);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, STK_BASE, arg->offPrm);
	if (start_reg != STK_BASE) {
		mono_call_inst_add_outarg_reg (s, call, treg, start_reg, FALSE);
	} else {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, 
					     STK_BASE, arg->offset, treg);
	}
}

stmt: OP_OUTARG_VT (OP_ICONST) {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;

	int start_reg = tree->sreg1;
	int size      = arg->size;
	int nregs     = size / 4;

//printf("OP_OUTARG_VT(OP_ICONST) %d\n",nregs);
	if (start_reg != STK_BASE) {
		if (nregs) {
			tree->opcode  = OP_ICONST;
			tree->dreg    = mono_regstate_next_int (s->rs);
			tree->inst_c0 = state->left->tree->inst_c0;
			mono_bblock_add_inst (s->cbb, tree);
			mono_call_inst_add_outarg_reg (s, call, tree->dreg, start_reg, FALSE);
		}
	} else {
		MONO_OUTPUT_VTS (s, size, STK_BASE, tree->inst_c0, 
				 s->frame_reg, tree->inst_offset);
	}
}

stmt: OP_OUTARG_VT (reg) {
	MonoCallInst *call   = (MonoCallInst*) tree->inst_right;
	MonoCallArgParm *arg = (MonoCallArgParm *) tree;
	MonoInst *vt         = state->left->left->tree;
	int start_reg        = tree->sreg1;
	int size             = arg->size;
	int soffset          = vt->inst_offset;
	int treg;

	if (size < 0) { 
		size = -size;
		treg = mono_regstate_next_int (s->rs);
		if (start_reg != STK_BASE) {
//printf("OP_OUTARG_VT(reg) 1\n");
			MONO_EMIT_NEW_MOVE (s, STK_BASE, arg->offPrm, state->left->reg1,
					    0, size);
			MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg,
						 STK_BASE, arg->offPrm);
			mono_call_inst_add_outarg_reg (s, call, treg, start_reg, FALSE);
		} else {
//printf("OP_OUTARG_VT(reg) 1\n");
			MONO_EMIT_NEW_MOVE (s, STK_BASE, soffset+size, state->left->reg1,
					    0, size);
			MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, STK_BASE,
						 soffset+size);
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, 
						     STK_BASE, arg->offset, treg);
		}
	} else {
		if (start_reg != STK_BASE) {
			MONO_OUTPUT_VTR (s, size, start_reg, STK_BASE, soffset);
		} else {
//printf("OP_OUTARG_VT(reg) 2\n");
			treg = mono_regstate_next_int (s->rs);
			MONO_OUTPUT_VTS (s, size, STK_BASE, soffset, treg,
					 state->left->tree->inst_offset);
			MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, STK_BASE, 
			 			 s->stack_offset);
		}
	}
}

stmt: OP_OUTARG_VT (OP_REFANYTYPE (reg)) "0" {
//printf("OP_OUTARG_VT (OP_REFANYTYPE (base))\n");
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->tree->sreg1, state->left->left->reg1, 
				    G_STRUCT_OFFSET (MonoTypedRef, type));
}	

stmt: CEE_STIND_R8 (OP_REGVAR, freg) {
	/* nothing to do: the value is already on the FP stack */
}

stmt: CEE_BNE_UN (fpcflags) {
	tree->opcode = OP_FBNE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BEQ (fpcflags) {
	tree->opcode = OP_FBEQ;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT (fpcflags) {
	tree->opcode = OP_FBLT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT_UN (fpcflags) {
	tree->opcode = OP_FBLT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT (fpcflags) {
	tree->opcode = OP_FBGT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT_UN (fpcflags) {
	tree->opcode = OP_FBGT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE  (fpcflags) {
	tree->opcode = OP_FBGE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE_UN (fpcflags) {
	tree->opcode = OP_FBGE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE  (fpcflags) {
	tree->opcode = OP_FBLE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE_UN (fpcflags) {
	tree->opcode = OP_FBLE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_POP (freg) "0" {
	/* nothing to do */
}     

freg: OP_LCONV_TO_R8 (lreg) {
	/* nothing to do - emulated */
}

freg: OP_LCONV_TO_R4 (lreg) {
	/* nothing to do - emulated */
}

freg: OP_LCONV_TO_R_UN (lreg) {
	/* nothing to do - emulated */
}

freg: OP_FREM (freg, freg) {
	/* nothing to do - emulated */
}

reg: OP_CEQ (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCEQ, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

base: OP_S390_STKARG "0" {
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, tmpr, s->frame_reg);
	tree->inst_offset  = state->tree->inst_offset;
	tree->inst_basereg = tmpr;
}

reg: CEE_LDIND_I4 (CEE_REFANYVAL (base)) "0" {
	MonoInst *base = state->left->left->left->tree;
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, base->sreg1, base->inst_offset);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, G_STRUCT_OFFSET (MonoTypedRef, value));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, tmpr, 4);
}

reg: CEE_LDIND_I2 (CEE_REFANYVAL (base)) "0" {
	MonoInst *base = state->left->left->left->tree;
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, base->sreg1, base->inst_offset);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, G_STRUCT_OFFSET (MonoTypedRef, value));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI2_MEMBASE, state->reg1, tmpr, 6);
}

reg: CEE_LDIND_I1 (CEE_REFANYVAL (base)) "0" {
	MonoInst *base = state->left->left->left->tree;
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, base->sreg1, base->inst_offset);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, G_STRUCT_OFFSET (MonoTypedRef, value));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI1_MEMBASE, state->reg1, tmpr, 7);
}

reg: CEE_LDIND_U4 (CEE_REFANYVAL (base)) "0" {
	MonoInst *base = state->left->left->left->tree;
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, base->sreg1, base->inst_offset);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, G_STRUCT_OFFSET (MonoTypedRef, value));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU4_MEMBASE, state->reg1, tmpr, 4);
}

reg: CEE_LDIND_U2 (CEE_REFANYVAL (base)) "0" {
	MonoInst *base = state->left->left->left->tree;
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, base->sreg1, base->inst_offset);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, G_STRUCT_OFFSET (MonoTypedRef, value));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU2_MEMBASE, state->reg1, tmpr, 6);
}

reg: CEE_LDIND_U1 (CEE_REFANYVAL (base)) "0" {
	MonoInst *base = state->left->left->left->tree;
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, base->sreg1, base->inst_offset);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, G_STRUCT_OFFSET (MonoTypedRef, value));
	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADU1_MEMBASE, state->reg1, tmpr, 7);
}

reg: OP_LDADDR (OP_S390_ARGREG),
reg: CEE_LDOBJ (OP_S390_ARGREG) "0" {
	MONO_EMIT_LOAD_MEMBASE (s, tree, state->reg1, s->frame_reg, state->left->tree->inst_offset);
}

base: OP_LDADDR (OP_S390_LOADARG) "0" {
	int treg;

	treg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, treg, s->frame_reg);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, treg, treg, state->left->tree->backend.arg_info);
	tree->inst_offset  = 0;
	tree->inst_basereg = treg;
}

base: OP_LDADDR (OP_S390_ARGPTR) "0" {
	int treg;

	treg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, s->frame_reg, 
				 state->left->tree->inst_offset);
	tree->inst_offset  = 0;
	tree->inst_basereg = treg;
}

base: OP_LDADDR (OP_S390_STKARG) "0" {
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, tmpr, s->frame_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, tmpr, 
				  state->left->tree->inst_offset);
	tree->inst_offset  = 0;
	tree->inst_basereg = tmpr;
}

reg: OP_LDADDR (OP_S390_LOADARG) {
	int treg;

	treg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, treg, s->frame_reg);
	MONO_EMIT_LOAD_MEMBASE (s, tree, state->reg1, treg, state->left->tree->inst_offset);
}

reg: OP_LDADDR (OP_S390_ARGPTR) "2" {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, s->frame_reg, 
				 state->left->tree->inst_offset);
	tree->inst_offset  = 0;
	tree->inst_basereg = state->reg1;
}

reg: OP_LDADDR (OP_S390_STKARG) "2" {
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, state->reg1, s->frame_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, state->reg1, 
				 (state->left->tree->backend.arg_info +
				  state->left->tree->inst_offset));
	tree->inst_offset  = 0;
	tree->inst_basereg = state->reg1;
}

reg: CEE_LDOBJ (OP_S390_LOADARG) "1" {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, s->frame_reg, 
				 state->left->tree->inst_offset);
}

reg: CEE_LDOBJ (OP_S390_ARGPTR) "0" {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, s->frame_reg, 
			     state->left->tree->inst_offset);
}

reg: CEE_LDOBJ (OP_S390_STKARG) "1" {
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, state->reg1, s->frame_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, state->reg1,
				 (state->left->tree->backend.arg_info +
				  state->left->tree->inst_offset));
	tree->inst_offset  = 0;
	tree->dreg 	   = state->reg1;
}

base: CEE_LDOBJ (OP_S390_ARGPTR) "0" {
	int treg;

	treg = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, treg, s->frame_reg, 
				    state->left->tree->inst_offset);
	tree->inst_offset  = 0;
	tree->inst_basereg = treg;
}

base: CEE_LDOBJ (OP_S390_STKARG) "0" {
	int tmpr;

	tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, OP_S390_BKCHAIN, tmpr, s->frame_reg);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, tmpr, tmpr, state->left->tree->backend.arg_info);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tmpr, tmpr, state->left->tree->inst_offset);
	tree->inst_offset  = 0;
	tree->inst_basereg = tmpr;
}


reg: OP_ATOMIC_ADD_NEW_I8 (base, reg),
reg: OP_ATOMIC_ADD_NEW_I4 (base, reg),
reg: OP_ATOMIC_ADD_I8 (base, reg),
reg: OP_ATOMIC_ADD_I4 (base, reg) {
	tree->inst_basereg = state->left->tree->inst_basereg; 
	tree->inst_offset = state->left->tree->inst_offset; 
	tree->dreg = state->reg1;
	tree->sreg2 = state->right->reg1;
    
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_ATOMIC_EXCHANGE_I8 (base, reg),
reg: OP_ATOMIC_EXCHANGE_I4 (base, reg) {
	tree->dreg = state->reg1;
	tree->sreg2 = state->right->reg1;
	tree->inst_basereg = state->left->tree->inst_basereg; 
	tree->inst_offset = state->left->tree->inst_offset; 
    
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LSHL (reg, reg),
reg: OP_LSHR (reg, reg),
reg: OP_LSHR_UN (reg, reg),
reg: OP_LMUL (reg, reg),
reg: OP_LDIV (reg, reg),
reg: OP_LDIV_UN (reg, reg),
reg: OP_LREM (reg, reg),
reg: OP_LREM_UN (reg, reg),
reg: OP_LMUL_OVF (reg, reg),
reg: OP_LMUL_OVF_UN (reg, reg) "0" {
	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1, state->right->reg1);
}

reg: OP_LSHL (reg, OP_ICONST) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_LSHL_IMM, state->reg1, state->left->reg1, state->right->tree->inst_c0);
} cost {
	MBCOND (mono_arch_is_inst_imm (state->right->tree->inst_c0));
	return 0;
}

reg: OP_LSHR (reg, OP_ICONST) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_LSHR_IMM, state->reg1, state->left->reg1, state->right->tree->inst_c0);
} cost {
	MBCOND (mono_arch_is_inst_imm (state->right->tree->inst_c0));
	return 0;
}

reg: OP_LSHR_UN (reg, OP_ICONST) {
	MONO_EMIT_BIALU_IMM (s, tree, OP_LSHR_UN_IMM, state->reg1, state->left->reg1, state->right->tree->inst_c0);
} cost {
	MBCOND (mono_arch_is_inst_imm (state->right->tree->inst_c0));
	return 0;
}

reg: OP_LCONV_TO_I4 (reg) "0" {
	/* Sign extend the value in the lower word into the upper word */
	MONO_EMIT_BIALU_IMM (s, tree, CEE_CONV_I4, state->reg1, state->left->reg1, 0);
}

reg: OP_LCONV_TO_U4 (reg) "0" {
	/* Clean out the upper word */
	MONO_EMIT_BIALU_IMM (s, tree, CEE_CONV_U4, state->reg1, state->left->reg1, 0);
}

freg: OP_LCONV_TO_R8 (reg) {
	/* FIXME: Move this inssel-long.brg */
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_LCONV_TO_R4 (reg) {
	/* FIXME: Move this inssel-long.brg */
	tree->sreg1 = state->left->reg1;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

%%
