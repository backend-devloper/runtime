%%

#
# inssel-sparc.brg: burg file for special sparc instructions
#
# Author:
#   Dietmar Maurer (dietmar@ximian.com)
#   Paolo Molaro (lupus@ximian.com)
#
# (C) 2002 Ximian, Inc.
#

stmt: CEE_STIND_I8 (OP_REGVAR, lreg) {
	/* this should only happen for methods returning a long */
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, sparc_o0, state->right->reg2);
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, sparc_o1, state->right->reg1);
}

lreg: CEE_LDIND_I8 (OP_REGVAR) {
	/* reg2 contains the most significant word */
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, state->reg2, state->left->tree->dreg);
	tree->opcode = OP_SETREG;
	tree->dreg = state->reg1;
	tree->sreg1 = state->left->tree->dreg + 1;
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_LCONV_TO_R8 (lreg) {
	mono_bblock_add_inst (s->cbb, tree);
}

freg: OP_LCONV_TO_R4 (lreg) {
	mono_bblock_add_inst (s->cbb, tree);
}

freg: CEE_CONV_R_UN (reg) {
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LOCALLOC (OP_ICONST) {
	/* microcoded in mini-sparc.c */
	tree->sreg1 = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_ICONST (s, tree->sreg1, state->left->tree->inst_c0);
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LOCALLOC (reg) {
	mono_bblock_add_inst (s->cbb, tree);
}

base: OP_SPARC_INARG_VT (base) {
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->tree->inst_basereg, 
					state->left->tree->inst_offset);
}

reg: OP_LDADDR (OP_SPARC_INARG_VT (base)) {
	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->left->tree->inst_basereg, 
					state->left->left->tree->inst_offset);
}

base: OP_LDADDR (reg) {
/*
	tree->inst_basereg = mono_regstate_next_int (s->rs);
	tree->inst_offset = 0;

	MONO_EMIT_NEW_LOAD_MEMBASE (s, tree->inst_basereg, state->left->tree->dreg, 0);
*/
	tree->inst_basereg = state->left->tree->dreg;
	tree->inst_offset = 0;
}

stmt: OP_OUTARG (OP_LDADDR (reg)) {
	tree->opcode = OP_SETREG;
	tree->dreg = tree->unused;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = sparc_i0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, sparc_i0, state->left->reg2);
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = sparc_i1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (freg) {
	MONO_EMIT_UNALU (s, tree, OP_FMOVE, sparc_f0, state->left->reg1);
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (OP_ICONST) {
	tree->opcode = OP_ICONST;
	tree->inst_c0 = state->left->tree->inst_c0;
	tree->dreg = sparc_i0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (reg) {
	tree->opcode = OP_SETREG;
	tree->dreg = tree->unused;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (OP_REGVAR) {
	tree->opcode = OP_SETREG;
	tree->dreg = tree->unused;
	tree->sreg1 = state->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (freg) {
	/* floating-point <-> integer transfer must go through memory */
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER4_MEMBASE_REG, tree->inst_basereg,
							 	tree->inst_imm, state->left->reg1);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tree->unused, tree->inst_basereg, tree->inst_imm);
}

stmt: OP_OUTARG (OP_ICONST) {
	tree->opcode = OP_SETREGIMM;
	tree->dreg = tree->unused;
	tree->inst_c0 = state->left->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_R4 (base)) {
	tree->opcode = OP_LOADI4_MEMBASE;
	tree->dreg = tree->unused;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SPARC_OUTARG_REGPAIR (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_SETREG, tree->unused, state->left->reg2);
	tree->opcode = OP_SETREG;
	tree->dreg = tree->unused + 1;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SPARC_OUTARG_REGPAIR (freg) {
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, tree->inst_basereg,
							 	tree->inst_imm, state->left->reg1);
	/* floating-point <-> integer transfer must go through memory */
	/* Load into a register pair */
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tree->unused, tree->inst_basereg, tree->inst_imm);
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tree->unused + 1, tree->inst_basereg, tree->inst_imm + 4);
}

stmt: OP_SPARC_OUTARG_MEM (reg) {
	if (tree->inst_imm & 0x1)
		tree->opcode = OP_STOREI1_MEMBASE_REG;
	else if (tree->inst_imm & 0x2)
		tree->opcode = OP_STOREI2_MEMBASE_REG;
	else
		tree->opcode = OP_STOREI4_MEMBASE_REG;
	tree->inst_destbasereg = tree->inst_basereg;
	tree->inst_offset = tree->inst_imm;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SPARC_OUTARG_MEM (freg) {
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER4_MEMBASE_REG, tree->inst_basereg,
							 	tree->inst_imm, state->left->reg1);
}

stmt: OP_SPARC_OUTARG_MEMPAIR (lreg) {
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, tree->inst_basereg,
						 		tree->inst_imm, state->left->reg2);
	tree->opcode = OP_STOREI4_MEMBASE_REG;
	tree->inst_destbasereg = tree->inst_basereg;
	tree->inst_offset = tree->inst_imm + 4;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SPARC_OUTARG_MEMPAIR (freg) {
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, tree->inst_basereg,
							 	tree->inst_imm, state->left->reg1);
}

stmt: OP_SPARC_OUTARG_SPLIT_REG_STACK (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_SETREG, tree->unused, state->left->reg2);
	tree->opcode = OP_STOREI4_MEMBASE_REG;
	tree->inst_destbasereg = tree->inst_basereg;
	tree->inst_offset = tree->inst_imm + 4;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SPARC_OUTARG_SPLIT_REG_STACK (freg) {
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER8_MEMBASE_REG, tree->inst_basereg,
							 	tree->inst_imm, state->left->reg1);
	/* floating-point <-> integer transfer must go through memory */
	/* Load most significant word into register */
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tree->unused, tree->inst_basereg, tree->inst_imm);
}

# Handles scalar valuetypes like RuntimeTypeHandle
reg: OP_OUTARG_VT (OP_ICONST) {
	int size = tree->unused;
	MONO_EMIT_NEW_STORE_MEMBASE_IMM (s, OP_STOREI4_MEMBASE_IMM, sparc_sp, tree->inst_c1, state->left->tree->inst_c0);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, sparc_sp, tree->inst_c1);
}

reg: OP_OUTARG_VT (base) {
	int size = tree->unused;
	mini_emit_memcpy (s, sparc_sp, tree->inst_c1, state->left->tree->inst_basereg, state->left->tree->inst_offset, size, 0);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, sparc_sp, tree->inst_c1);
}

stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
	tree->opcode = OP_SETREG;
	tree->sreg1 = state->left->left->tree->dreg;
	tree->dreg = tree->unused;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGOFFSET)) {
	MONO_EMIT_NEW_LOAD_MEMBASE (s, tree->unused, state->left->left->tree->inst_basereg, 
								state->left->left->tree->inst_offset);
}

stmt: OP_OUTARG_VT (OP_ICONST) {
	tree->opcode = OP_SETREGIMM;
	tree->dreg = tree->unused;
	tree->inst_imm = state->left->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_R8 (OP_REGVAR, freg) {
	/* nothing to do: the value is already on the FP stack */
}

reg: CEE_LDIND_I2 (OP_REGVAR) {
	/* All regs are 32 bit */
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->tree->dreg;
	tree->dreg = state->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BNE_UN (fpcflags) {
	tree->opcode = OP_FBNE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BEQ (fpcflags) {
	tree->opcode = OP_FBEQ;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT (fpcflags) {
	tree->opcode = OP_FBLT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT_UN (fpcflags) {
	tree->opcode = OP_FBLT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT (fpcflags) {
	tree->opcode = OP_FBGT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT_UN (fpcflags) {
	tree->opcode = OP_FBGT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE  (fpcflags) {
	tree->opcode = OP_FBGE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE_UN (fpcflags) {
	tree->opcode = OP_FBGE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE  (fpcflags) {
	tree->opcode = OP_FBLE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE_UN (fpcflags) {
	tree->opcode = OP_FBLE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_POP (freg) "0" {
	/* nothing to do */
}     

stmt: OP_START_HANDLER {
}

stmt: CEE_ENDFINALLY {
}

stmt: OP_ENDFILTER (reg) {
}

reg: OP_CEQ (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCEQ, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

#
# Optimizations
#

stmt: OP_SETRET (CEE_LDIND_REF(base)) {
	MONO_EMIT_LOAD_MEMBASE (s, tree, sparc_i0, state->left->left->tree->inst_basereg, 
				state->left->left->tree->inst_offset);	
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (CEE_LDIND_I4(base)) {
	MONO_EMIT_LOAD_MEMBASE (s, tree, sparc_i0, state->left->left->tree->inst_basereg, 
				state->left->left->tree->inst_offset);	
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (CEE_LDIND_I(base)) {
	MONO_EMIT_LOAD_MEMBASE (s, tree, sparc_i0, state->left->left->tree->inst_basereg, 
				state->left->left->tree->inst_offset);	
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I (OP_REGVAR)) {
	tree->opcode = OP_SETREG;
	tree->dreg = tree->unused;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I4 (OP_REGVAR)) {
	tree->opcode = OP_SETREG;
	tree->dreg = tree->unused;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LDADDR (OP_REGOFFSET) "1" {
	if (state->left->tree->inst_offset) {
		MONO_EMIT_BIALU_IMM (s, tree, OP_ADD_IMM, state->reg1, state->left->tree->inst_basereg, state->left->tree->inst_offset);
	} else {
		tree->opcode = OP_MOVE;
		tree->sreg1 = state->left->tree->inst_basereg;
		tree->dreg = state->reg1;
	}
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_MEMSET (reg) "0" {
	int size = tree->unused;
	int offset = 0;
	int destreg = state->left->reg1;
	int val_reg;

	if (tree->inst_imm) {
		val_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_ICONST (s, val_reg, tree->inst_imm);
	}
	else
		val_reg = sparc_g0;

	if ((tree->inst_imm == 0) && (size >= 8)) {
		MONO_EMIT_NEW_ICONST (s, sparc_g1, 0);

		while (size >= 8) {
			MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI8_MEMBASE_REG, destreg, offset, val_reg);
			offset += 8;
			size -= 8;
		}
	}
		
	while (size >= 4) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI4_MEMBASE_REG, destreg, offset, val_reg);
		offset += 4;
		size -= 4;
	}
	while (size >= 2) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI2_MEMBASE_REG, destreg, offset, val_reg);
		offset += 2;
		size -= 2;
	}
	while (size >= 1) {
		MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STOREI1_MEMBASE_REG, destreg, offset, val_reg);
		offset += 1;
		size -= 1;
	}
}

%%
