%%

#
# inssel-x86.brg: burg file for special x86 instructions
#
# Author:
#   Dietmar Maurer (dietmar@ximian.com)
#   Paolo Molaro (lupus@ximian.com)
#
# (C) 2002 Ximian, Inc.
#

stmt: CEE_STIND_I8 (OP_REGVAR, lreg) {
	/* this should only happen for methods returning a long */
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, X86_EAX, state->right->reg1);
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, X86_EDX, state->right->reg2);
}

lreg: OP_LNEG (lreg) "3" {
	int tmpr = mono_regstate_next_int (s->rs);
	MONO_EMIT_NEW_UNALU (s, CEE_NEG, state->reg1, state->left->reg1);
	MONO_EMIT_BIALU_IMM (s, tree, OP_ADC_IMM, tmpr, state->left->reg2, 0);
	MONO_EMIT_NEW_UNALU (s, CEE_NEG, state->reg2, tmpr);
}

freg: OP_LCONV_TO_R8 (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_X86_PUSH, -1, state->left->reg2);
	MONO_EMIT_NEW_UNALU (s, OP_X86_PUSH, -1, state->left->reg1);
	tree->opcode = OP_X86_FP_LOAD_I8;
	tree->inst_basereg = X86_ESP;
	tree->inst_offset = 0;
	mono_bblock_add_inst (s->cbb, tree);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, X86_ESP, X86_ESP, 8);
}

freg: OP_LCONV_TO_R4 (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_X86_PUSH, -1, state->left->reg2);
	MONO_EMIT_NEW_UNALU (s, OP_X86_PUSH, -1, state->left->reg1);
	tree->opcode = OP_X86_FP_LOAD_I8;
	tree->inst_basereg = X86_ESP;
	tree->inst_offset = 0;
	mono_bblock_add_inst (s->cbb, tree);
	/* change precision */
	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORER4_MEMBASE_REG, X86_ESP, 0, state->reg1);
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADR4_MEMBASE, state->reg1, X86_ESP, 0);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, X86_ESP, X86_ESP, 8);
}

freg: CEE_CONV_R_UN (reg) {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_X86_PUSH_IMM, -1, -1, 0);
	MONO_EMIT_NEW_UNALU (s, OP_X86_PUSH, -1, state->left->reg1);
	tree->opcode = OP_X86_FP_LOAD_I8;
	tree->inst_basereg = X86_ESP;
	tree->inst_offset = 0;
	mono_bblock_add_inst (s->cbb, tree);
	MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, X86_ESP, X86_ESP, 8);
}

cflags: OP_COMPARE (CEE_LDIND_I4 (base), reg) {
	tree->opcode = OP_X86_COMPARE_MEMBASE_REG;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	tree->sreg2 = state->right->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

cflags: OP_COMPARE (CEE_LDIND_I4 (base), OP_ICONST) {
	tree->opcode = OP_X86_COMPARE_MEMBASE_IMM;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	tree->inst_imm = state->right->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);
}

cflags: OP_COMPARE (reg, CEE_LDIND_I4 (base)) {
	tree->opcode = OP_X86_COMPARE_REG_MEMBASE;
	tree->sreg2 = state->right->left->tree->inst_basereg;
	tree->inst_offset = state->right->left->tree->inst_offset;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: OP_LOCALLOC (OP_ICONST) {
	if (tree->flags & MONO_INST_INIT) {
		/* microcoded in mini-x86.c */
		tree->sreg1 = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_ICONST (s, tree->sreg1, state->left->tree->inst_c0);
		mono_bblock_add_inst (s->cbb, tree);
	} else {
		MONO_EMIT_NEW_BIALU_IMM (s, OP_SUB_IMM, X86_ESP, X86_ESP, state->left->tree->inst_c0);
		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, X86_ESP);
	}
}

reg: OP_LOCALLOC (reg) {
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (reg) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = X86_EAX;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_MOVE, X86_EDX, state->left->reg2);
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->reg1;
	tree->dreg = X86_EAX;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (CEE_LDIND_REF (OP_REGVAR)) {
	tree->opcode = OP_MOVE;
	tree->sreg1 = state->left->left->tree->dreg;
	tree->dreg = X86_EAX;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_SETRET (freg) {
	/* nothing to do */
}

stmt: OP_SETRET (OP_ICONST) {
	tree->opcode = OP_ICONST;
	tree->inst_c0 = state->left->tree->inst_c0;
	tree->dreg = X86_EAX;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (reg) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

# we need to reduce this code duplication with some burg syntax extension
stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I4 (OP_REGVAR)) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_U4 (OP_REGVAR)) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I (OP_REGVAR)) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (lreg) {
	MONO_EMIT_NEW_UNALU (s, OP_X86_PUSH, -1, state->left->reg2);
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I8 (base)) {
	MonoInst *ins;
	ins = mono_mempool_alloc0 (s->mempool, sizeof (MonoInst));
	ins->opcode = OP_X86_PUSH_MEMBASE;
	ins->inst_basereg = state->left->left->tree->inst_basereg;
	ins->inst_offset = state->left->left->tree->inst_offset + 4;
	mono_bblock_add_inst (s->cbb, ins);

	tree->opcode = OP_X86_PUSH_MEMBASE;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (OP_ICONST) {
	tree->opcode = OP_X86_PUSH_IMM;
	tree->inst_imm = state->left->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I4 (base)) {
	tree->opcode = OP_X86_PUSH_MEMBASE;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_U4 (base)) {
	tree->opcode = OP_X86_PUSH_MEMBASE;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_I (base)) {
	tree->opcode = OP_X86_PUSH_MEMBASE;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_REF (base)) {
	tree->opcode = OP_X86_PUSH_MEMBASE;
	tree->inst_basereg = state->left->left->tree->inst_basereg;
	tree->inst_offset = state->left->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->left->tree->dreg;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (CEE_LDOBJ (reg)) {
	tree->opcode = OP_X86_PUSH;
	tree->sreg1 = state->left->reg1;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG (freg) {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SUB_IMM, X86_ESP, X86_ESP, 8);
	tree->opcode = OP_STORER8_MEMBASE_REG;
	tree->sreg1 = state->left->reg1;
	tree->inst_destbasereg = X86_ESP;
	tree->inst_offset = 0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG_R4 (freg) {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SUB_IMM, X86_ESP, X86_ESP, 4);
	tree->opcode = OP_STORER4_MEMBASE_REG;
	tree->sreg1 = state->left->reg1;
	tree->inst_destbasereg = X86_ESP;
	tree->inst_offset = 0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG_R8 (freg) {
	MONO_EMIT_NEW_BIALU_IMM (s, OP_SUB_IMM, X86_ESP, X86_ESP, 8);
	tree->opcode = OP_STORER8_MEMBASE_REG;
	tree->sreg1 = state->left->reg1;
	tree->inst_destbasereg = X86_ESP;
	tree->inst_offset = 0;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: OP_OUTARG_VT (CEE_LDOBJ (base)) {
	MonoInst *vt = state->left->left->tree;
	//g_print ("vt size: %d at R%d + %d\n", tree->inst_imm, vt->inst_basereg, vt->inst_offset);
	if (tree->inst_imm <= 4) {
		tree->opcode = OP_X86_PUSH_MEMBASE;
		tree->inst_basereg = vt->inst_basereg;
		tree->inst_offset = vt->inst_offset;
		mono_bblock_add_inst (s->cbb, tree);
	} else {
		tree->opcode = OP_X86_PUSH_OBJ;
		tree->inst_basereg = vt->inst_basereg;
		tree->inst_offset = vt->inst_offset;
		mono_bblock_add_inst (s->cbb, tree);
	}
}

stmt: OP_OUTARG_VT (OP_ICONST) {
	tree->opcode = OP_X86_PUSH_IMM;
	tree->inst_imm = state->left->tree->inst_c0;
	mono_bblock_add_inst (s->cbb, tree);
}

reg: CEE_LDELEMA (reg, reg) "15" {
	int length_reg = mono_regstate_next_int (s->rs);
	guint32 size = mono_class_array_element_size (tree->klass);
	
	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, length_reg, 
				       state->left->reg1, G_STRUCT_OFFSET (MonoArray, max_length));
	MONO_EMIT_NEW_BIALU (s, OP_COMPARE, -1, length_reg, state->right->reg1);
	MONO_EMIT_NEW_COND_EXC (s, LE_UN, "IndexOutOfRangeException");

	if (size == 1 || size == 2 || size == 4 || size == 8) {
		static const int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };
		tree->opcode = OP_X86_LEA;
		tree->dreg = state->reg1;
		tree->sreg1 = state->left->reg1;
		tree->sreg2 = state->right->reg1;
		tree->inst_imm = G_STRUCT_OFFSET (MonoArray, vector);
		tree->unused = fast_log2 [size];
		mono_bblock_add_inst (s->cbb, tree);
	} else {
		int mult_reg = mono_regstate_next_int (s->rs);
		int add_reg = mono_regstate_next_int (s->rs);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, mult_reg, state->right->reg1, size);
		MONO_EMIT_NEW_BIALU (s, CEE_ADD, add_reg, mult_reg, state->left->reg1);
		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoArray, vector));
	}
}

stmt: CEE_STIND_R8 (OP_REGVAR, freg) {
	/* nothing to do: the value is already on the FP stack */
}

stmt: CEE_STIND_I4 (base, CEE_ADD (CEE_LDIND_I4 (base), OP_ICONST)) {
	int con = state->right->right->tree->inst_c0;	

	if (con == 1) {
		tree->opcode = OP_X86_INC_MEMBASE;
	} else {
		tree->opcode = OP_X86_ADD_MEMBASE_IMM;
		tree->inst_imm = con;
	}

	tree->inst_basereg = state->left->tree->inst_basereg;
	tree->inst_offset = state->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
} cost {
	MBTREE_TYPE *t1 = state->right->left->left->tree;
	MBTREE_TYPE *t2 = state->left->tree;
	MBCOND (t1->inst_basereg == t2->inst_basereg &&
		t1->inst_offset == t2->inst_offset);
	return 2;
}

stmt: CEE_STIND_I4 (base, CEE_SUB (CEE_LDIND_I4 (base), OP_ICONST)) {
	int con = state->right->right->tree->inst_c0;	

	if (con == 1) {
		tree->opcode = OP_X86_DEC_MEMBASE;
	} else {
		tree->opcode = OP_X86_SUB_MEMBASE_IMM;
		tree->inst_imm = con;
	}

	tree->inst_basereg = state->left->tree->inst_basereg;
	tree->inst_offset = state->left->tree->inst_offset;
	mono_bblock_add_inst (s->cbb, tree);
} cost {
	MBTREE_TYPE *t1 = state->right->left->left->tree;
	MBTREE_TYPE *t2 = state->left->tree;
	MBCOND (t1->inst_basereg == t2->inst_basereg &&
		t1->inst_offset == t2->inst_offset);
	return 2;
}

#
# this rules is incorrect, it needs to do an indirect inc (inc_membase)
#stmt: CEE_STIND_I4 (reg, CEE_ADD (reg, OP_ICONST)) {
#	tree->opcode = OP_X86_INC_REG;
#	tree->dreg = state->left->reg1;
#	mono_bblock_add_inst (s->cbb, tree);
#} cost {
#	MBState *s1 = state->left;
#	MBState *s2 = state->right->left;
#	int con = state->right->right->tree->inst_c0;	
#	MBCOND (con == 1 && s1->reg1 == s2->reg1);
#	return 1;
#}

stmt: CEE_STIND_I4 (OP_REGVAR, CEE_SUB (CEE_LDIND_I4 (OP_REGVAR), OP_ICONST)) {
	int con = state->right->right->tree->inst_c0;	
	int dreg = state->left->tree->dreg;
	int sreg = state->right->left->left->tree->dreg;

	if (con == 1) {
		if (dreg != sreg)
			MONO_EMIT_NEW_UNALU (s, OP_MOVE, dreg, sreg);
		tree->opcode = OP_X86_DEC_REG;
		tree->dreg = tree->sreg1 = dreg;
	} else if (con == -1) {
		if (dreg != sreg)
			MONO_EMIT_NEW_UNALU (s, OP_MOVE, dreg, sreg);
		tree->opcode = OP_X86_INC_REG;
		tree->dreg = tree->sreg1 = dreg;
	} else {
		tree->opcode = OP_SUB_IMM;
		tree->inst_imm = con;
		tree->sreg1 = sreg;
		tree->dreg = dreg;
	}
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_STIND_I4 (OP_REGVAR, CEE_ADD (CEE_LDIND_I4 (OP_REGVAR), OP_ICONST)) {
	int con = state->right->right->tree->inst_c0;
	int dreg = state->left->tree->dreg;
	int sreg = state->right->left->left->tree->dreg;

	if (con == 1) {
		if (dreg != sreg)
			MONO_EMIT_NEW_UNALU (s, OP_MOVE, dreg, sreg);
		tree->opcode = OP_X86_INC_REG;
		tree->dreg = tree->sreg1 = dreg;
	} else if (con == -1) {
		if (dreg != sreg)
			MONO_EMIT_NEW_UNALU (s, OP_MOVE, dreg, sreg);
		tree->opcode = OP_X86_DEC_REG;
		tree->dreg = tree->sreg1 = dreg;
	} else {
		tree->opcode = OP_ADD_IMM;
		tree->inst_imm = con;
		tree->sreg1 = sreg;
		tree->dreg = dreg;
	}
	mono_bblock_add_inst (s->cbb, tree);
}

# on x86, fp compare overwrites EAX, so we must
# either improve the local register allocator or
# emit coarse opcodes which saves EAX for us.

reg: OP_CEQ (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCEQ, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CLT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCLT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

reg: OP_CGT_UN (OP_COMPARE (freg, freg)) {	
	MONO_EMIT_BIALU (s, tree, OP_FCGT_UN, state->reg1, state->left->left->reg1,
			 state->left->right->reg1);
}

# fpcflags overwrites EAX, but this does not matter for statements
# because we are the last operation in the tree.
 
stmt: CEE_BNE_UN (fpcflags) {
	tree->opcode = OP_FBNE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BEQ (fpcflags) {
	tree->opcode = OP_FBEQ;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT (fpcflags) {
	tree->opcode = OP_FBLT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLT_UN (fpcflags) {
	tree->opcode = OP_FBLT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT (fpcflags) {
	tree->opcode = OP_FBGT;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGT_UN (fpcflags) {
	tree->opcode = OP_FBGT_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE  (fpcflags) {
	tree->opcode = OP_FBGE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BGE_UN (fpcflags) {
	tree->opcode = OP_FBGE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE  (fpcflags) {
	tree->opcode = OP_FBLE;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_BLE_UN (fpcflags) {
	tree->opcode = OP_FBLE_UN;
	mono_bblock_add_inst (s->cbb, tree);
}

stmt: CEE_POP (freg) "0" {
	/* we need to pop the value from the x86 FP stack */
	MONO_EMIT_UNALU (s, tree, OP_X86_FPOP, -1, state->left->reg1);	
}     

%%
